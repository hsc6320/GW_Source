/*
 * MsgHandler.cpp
 *
 *  Created on: 2021. 11. 30.
 *      Author: hong
 */

#include "MsgHandler.h"

BYTE* m_p8uData;

MsgHandler::MsgHandler()
{
	m_pCommUart = NULL;
}

MsgHandler::~MsgHandler()
{
	// TODO Auto-generated destructor stub
}

int MsgHandler::ServiceStart()
{
	int ret =0;
	uint8_t pu8data[15] = {0xaa, 0, 0xfc, 0x01, 0, 0x01, 0, 0x05, 0x01, 0, 0, 0x04, 0xa5, 0x5a, 0x7e};
	printf("ServiceStart\n");
	ret = m_pCommUart->Uart_Write(m_pCommUart->m_uartd, pu8data, 16);

	return ret;
}

void MsgHandler::ServiceIdle()
{
	uint8_t pu8data[14] = {0xaa, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x10, 0, 0, 0x0a, 0xa5, 0x5a, 0x7e};
	printf("ServiceIdle\n");
	m_pCommUart->Uart_Write(m_pCommUart->m_uartd, pu8data, 16);
}

void MsgHandler::BypassSocketToUart(BYTE* p8Data, int DataLen, int msgtype)
{
	int status;
	printf("msgtype: %d, DataLen: %d \n", msgtype, DataLen);

	switch(msgtype)
	{
	case SERVICESTART_REQUEST:
		printf("SERVICESTART_REQUEST UART_WRITE\n");
		m_pCommUart->m_grun =1;
		m_pCommUart->Uart_Write(m_pCommUart->m_uartd, p8Data, DataLen);
		wait(&status);
		break;
	case COORDINATOR_RESET_REQ:
		m_pCommUart->m_grun =1;
		m_pCommUart->Uart_Write(m_pCommUart->m_uartd, p8Data, DataLen);
		wait(&status);
		break;
	}

}

void MsgHandler::BypassUartToSocket(BYTE* p8Data, int DataLen, int msgtype)
{

}
int MsgHandler::SetUartMsg(Vector<uint8_t> vec, int Len)
{
	SENDPACKET::SOCKET_PACKET	Getpacket;
	int size =0;
	int ipos =0;
	int loopEnd =0;
	int nlsChecksum =0;
	int loop =0;
	printf("GetUartMsg\n");

	m_p8uData = new BYTE[Len];

	while(!loopEnd) {
		switch(ipos)
		{
		case 0:
			if(vec[MSG_STX] != STX) {
				return 0;
				break;
			}
			else {
				m_p8uData[ipos] = vec[MSG_STX];
				ipos++;
			}
			break;
		case 1:
			m_p8uData[ipos] = vec[MSG_PANIDZERO];
			m_p8uData[++ipos] = vec[MSG_PANIDONE];

			m_p8uData[++ipos] = vec[MSG_DADDRZERO];
			m_p8uData[++ipos] = vec[MSG_DADDRONE];

			m_p8uData[++ipos] = vec[MSG_SADDRZERO];
			m_p8uData[++ipos] = vec[MSG_SADDRONE];

			m_p8uData[++ipos] = vec[MSGTYPE];

			m_p8uData[++ipos] = vec[MSG_LENGTHZERO];
			m_p8uData[++ipos] = vec[MSG_LENGTHONE];

			loop = ByteToWord(vec[MSG_LENGTHONE], vec[MSG_LENGTHZERO]);
			for(int i =0; i< (int)loop; i++) {
				m_p8uData[++ipos] = vec[MSG_LENGTHONE+1+i];
				printf("pu8Data [%x] ", m_p8uData[ipos]);
			}
			ipos = ipos + (int)loop;
			break;
		default:
			if(!nlsChecksum) {
				Getpacket.tail.checksum = vec[ipos];
				printf("checksum Val :%x ", Getpacket.tail.checksum);
				nlsChecksum =1;
			//	GetChecksum((BYTE *)&Getpacket.header.panID, (int)Getpacket.header.length);
				ipos++;
				break;
			}
			else {
				Getpacket.tail.ext[0] = vec[ipos];
				Getpacket.tail.ext[1] = vec[++ipos];
				Getpacket.tail.ext[2] = vec[++ipos];

				if((Getpacket.tail.ext[0] != 0xA5) || (Getpacket.tail.ext[1] != 0x5A) || (Getpacket.tail.ext[2] != 0x7E)) {
					printf("etx error return 0\n");
					size = vec.size();
					vec.remove(size+1);
					return 0;
				}
				else {
					printf("pos[%d]etx : %x %x %x\n", ipos, Getpacket.tail.ext[0], Getpacket.tail.ext[1], Getpacket.tail.ext[2]);
					loopEnd =1;
					nlsChecksum =0;
					size = vec.size();
					vec.remove(size+1);
					break;
				}
			}

		}		//END SWITCH
	}		//END WHILE

	printf("return 1\n");
	return 1;
}

WORD MsgHandler::ByteToWord(BYTE puData, BYTE puData1)
{
	WORD p16Tempdata_HIGH, p16Tempdata_LOW;

	p16Tempdata_HIGH = (puData << 8);
	p16Tempdata_LOW = puData1;

	return p16Tempdata_HIGH|p16Tempdata_LOW;

}

void MsgHandler::SetHandle(UartComThread* msg)
{
	m_pCommUart = msg;
}
