/*
 * MsgQueue.cpp
 *
 *  Created on: 2021. 11. 29.
 *      Author: hong
 */

#include "MsgQueue.h"
#include <queue>

using namespace std;

int m_uiPos =0;
int nLengthCnt =0;
int nDatalength =0;
BYTE m_u8SendData[1024];

std::vector<uint8_t*> vec;

int m_nAssoCnt =0;
int bAssociEnd =0;
int iTimerflag =0;
std::queue<BYTE> que2;
msgform* m_pMsg;
Socket* m_GetSocket;
pthread_mutex_t Queuemutex;
struct itimerval timer;

MsgQueue:: MsgQueue(void)
{
	m_bReadEnd_UartMessage = 0;
	m_bUartCommuniFlag = 0;
	m_nMapParity =0;
	Redown =0;
	m_Uart_ServiceStart_TagAssociation_InitFlag =0;
	m_pMsg = NULL;
}

MsgQueue::~MsgQueue(void)
{
}

static void timer_handler(int signum)
{
	int i=0;

	//printf("\nTimer Data : ");
	while(!que2.empty()) {
		m_u8SendData[i] = que2.front();
		//printf("%x ", m_u8SendData[i]);
		que2.pop();
		if((m_u8SendData[i-3] == 0xa5) && (m_u8SendData[i-2] == 0x5a) && (m_u8SendData[i-1] == 0x7e) && (i > 18)) {
			//printf("\n");
			nDatalength = 23;
			m_GetSocket->Send_Message(m_u8SendData, nDatalength);
			memset(m_u8SendData, 0, 1024);
			m_nAssoCnt--;
			printf("m_nAssoCnt %d\n", m_nAssoCnt);
			break;
		}
		i++;

	}
	if(!m_nAssoCnt && !iTimerflag) {
		bAssociEnd =1;
		timer.it_interval.tv_usec =0;
		timer.it_value.tv_sec = 0;
		timer.it_value.tv_usec = 0;
		printf("Timer End bAssociEnd : %d\n", bAssociEnd);
		setitimer(ITIMER_VIRTUAL, &timer, NULL);
	}
}


int MsgQueue::uart_SetTimer()
{
	struct sigaction sa;
	struct itimerval timer;

	memset(&sa, 0, sizeof(sa));
	sa.sa_handler = &timer_handler;
	sigaction(SIGVTALRM, &sa, NULL);


	timer.it_interval.tv_sec = 0;
	timer.it_interval.tv_usec = 4000;

	timer.it_value.tv_sec = 0;
	timer.it_value.tv_usec = 500000;

	printf("SetTimer() \n");
	setitimer(ITIMER_VIRTUAL, &timer, NULL);

	return 1;
}


bool MsgQueue::PutByte(uint8_t* b, int len)
{
	BYTE u8Data[1024];
	memset(m_u8SendData, 0, 1024);
	memset(u8Data, 0, 1024);
	memcpy(u8Data, b, 1024);

	printf("PutByte()\n");

	if(u8Data[MSG_STX] == STX) {
		if(u8Data[MSGTYPE] == DATA_ACKNOWLEDGEMENT) {
			m_MsgQueueDataAcknowledge.clear();
			m_MsgQueueDataAcknowledge.push_back(ByteToWord(u8Data[MSG_SADDRONE], u8Data[MSG_SADDRZERO]));

			m_MsgQueueArrayDataAcknowledge.push_back(m_MsgQueueDataAcknowledge);

			printf("m_nMapParity : ");
			for(int i=0; i<(int)m_MsgQueueArrayDataAcknowledge[m_nMapParity].size(); i++) {
				printf("%x\n",m_MsgQueueArrayDataAcknowledge[m_nMapParity].at(i));
			}
			if(Redown) {
				m_ArrayDataAcknowledge.push_back(m_MsgQueueDataAcknowledge);
			}

			m_nMapParity++;
			m_GetSocket->Send_Message(u8Data, len);
		}
		else if((u8Data[MSGTYPE] == TAG_ASSOCIATION) || (u8Data[MSGTYPE] == DOWNLOAD_START_ACK)
				|| (u8Data[MSGTYPE] == DATAINDICATION_ACK) || (u8Data[MSGTYPE] == TAG_INFOR_UPDATE)
				|| (u8Data[MSGTYPE] == BSN_START_ACK)
				|| (u8Data[MSGTYPE] == BSN_DATA_END_ACK)
				|| (u8Data[MSGTYPE] == COORDINATOR_RESET_CONFIRM)
				|| (u8Data[MSGTYPE] == TAG_INFOR_UPDATE_ACK)
				|| (u8Data[MSGTYPE] == TAG_ALARM_INDICATION)
				/*|| (u8Data[MSGTYPE] == SERVICESTART_CONFIRM)*/) {

			if(u8Data[MSGTYPE] == TAG_ASSOCIATION) {
				printf("TAG_ASSOCIATION bAssociEnd : %d\n", bAssociEnd);
			/*	if(!bAssociEnd) {
					while(1) {
						que2.push(u8Data[i]);
						printf("<%x> ", u8Data[i]);
						if((u8Data[i-3] == 0xa5) && (u8Data[i-2] == 0x5a) && (u8Data[i-1] == 0x7e) && (i > 18)) {
							break;
						}
						i++;
					}
					m_nAssoCnt++;
					printf("\nm_nAssoCnt++ : %d\n", m_nAssoCnt);
					if(!iTimerflag) {
						iTimerflag =1;
						uart_SetTimer();
					}
				}
				else {}*/
					memcpy(m_u8SendData, u8Data, len);
					m_GetSocket->Send_Message(u8Data, len);
			}
			else if((u8Data[MSGTYPE] == COORDINATOR_RESET_CONFIRM) || (u8Data[MSGTYPE] == TAG_INFOR_UPDATE) || (u8Data[MSGTYPE] == TAG_INFOR_UPDATE_ACK)
					|| (u8Data[MSGTYPE] == TAG_ALARM_INDICATION) || (u8Data[MSGTYPE] == MULTI_GATEWAY_SCAN_CONFIRM) || (u8Data[MSGTYPE] == MULTI_GATEWAY_SCAN_RESPONESE)) {
				if(u8Data[MSGTYPE] == COORDINATOR_RESET_CONFIRM)	{
					memcpy(m_u8SendData, u8Data, len);
					bAssociEnd = 0;
					iTimerflag = 0;
					m_bUartCommuniFlag = 0;
					printf("bAssociEnd %d iTimerflag %d m_bUartCommuniFlag %d\n", bAssociEnd, iTimerflag, m_bUartCommuniFlag);
				}
				m_GetSocket->Send_Message(u8Data, len);
			}
			else {
				if(!m_bUartCommuniFlag && (u8Data[MSGTYPE] == BSN_START_ACK)) {
					iTimerflag =0;
					if(!bAssociEnd) {
				//		return 1;
					}
					m_vcemsg.MsgPacket.u8MsgType = u8Data[MSGTYPE];
					m_vcemsg.MsgPacket.data[0] = u8Data[MSG_DATA];
					printf("BSN_START_ACK msgtype : %x, becondata : %x \n", m_vcemsg.MsgPacket.u8MsgType, m_vcemsg.MsgPacket.data[0]);
					m_bUartCommuniFlag = 1;
					return 1;
				}
				else if( (u8Data[MSGTYPE] == DATAINDICATION_ACK) || (u8Data[MSGTYPE] == DOWNLOAD_START_ACK) ) {
					m_vcemsg.MsgPacket.u8MsgType = u8Data[MSGTYPE];
					if(u8Data[MSGTYPE] == DOWNLOAD_START_ACK) {
						m_vcemsg.MsgPacket.Saddr[0] = u8Data[MSG_SADDRZERO];
						m_vcemsg.MsgPacket.Saddr[1] = u8Data[MSG_SADDRONE];
					}
					else if(u8Data[MSGTYPE] == DATAINDICATION_ACK) {
						m_vcemsg.MsgPacket.Saddr[0] = u8Data[MSG_SADDRZERO];
						m_vcemsg.MsgPacket.Saddr[1] = u8Data[MSG_SADDRONE];
					}
					m_bUartCommuniFlag = 1;
				}
			}
		}
		else if( (u8Data[MSGTYPE] == 0) && (u8Data[MSGTYPE] == BSN_DATA_END_ACK) ) {
			return 1;
		}
		else {
			memcpy(m_u8SendData, u8Data, len);
			for(int i=0; i< len; i++) {
				m_vcemsg.m_UartMsg_vec.push_back(u8Data[i]);
				printf("[%x] ", m_vcemsg.m_UartMsg_vec[i]);
			}
			printf("\n");
			m_bReadEnd_UartMessage =1;
		}
	}

	return 1;
}

WORD MsgQueue::ByteToWord(BYTE puData, BYTE puData1)
{
	WORD p16Tempdata_HIGH, p16Tempdata_LOW;

	p16Tempdata_HIGH = (puData << 8);
	p16Tempdata_LOW = puData1;

	return p16Tempdata_HIGH|p16Tempdata_LOW;
}



void MsgQueue::GetSocket(Socket* soc)
{
	m_GetSocket = soc;
}



