/*
 * uart.cpp
 *
 *  Created on: 2021. 11. 29.
 *      Author: hong
 */

#include "uart.h"
#define BUF_MAX 512
using namespace std;

int fd;
int ii = 0;

uint8_t buf[BUF_MAX];

void uart_init()
{


	fd = open("/dev/ttyS1", O_RDWR | O_NOCTTY);
	printf("!!!Hello Welcome to Haemcom World~~2!!! %d\n", fd);

	if (fd < 0) {
		fprintf(stderr, "ERR\n");
		exit(-1);
	}

	struct termios newtio;
	// newtio <-- serial port setting.
	memset(&newtio, 0, sizeof(struct termios));
	newtio.c_cflag = B230400 | CS8 | CLOCAL | CREAD;
	newtio.c_iflag = IGNPAR /*| ICRNL*/;
	newtio.c_oflag = 0;
	newtio.c_lflag = ~(ICANON | ECHO | ECHOE | ISIG);

	tcflush(fd, TCIFLUSH);
	tcsetattr(fd, TCSANOW, &newtio);



}

static void *PrintHello(void *threadid) {

   long tid;
   tid = (long)threadid;
   printf("Hello World! Thread ID,\n");
   uint8_t pu8data[15] = {0xaa, 0, 0xfc, 0x01, 0, 0x01, 0, 0x05, 0x01, 0, 0, 0x04, 0xa5, 0x5a, 0x7e};

	const char *str = "hello, first serial program. \r\n";
	//write(fd, str, strlen(str) + 1);
	write(fd, pu8data, 16);
	printf("Write result %d\r\n ", fd);

	if (fd < 0) {
			fprintf(stderr, "ERR\n");
			printf("error\n");
			exit(-1);
	}
	/*else {
		for(int i=0; i< 15; i++) {
			printf("%x ", pu8data[i]);
		}
	}*/

	while(1) {
		ii = read(fd, buf, BUF_MAX);
		buf[ii] = '\n';
		printf(" %x %x %x %x %x %x %x %x %x %x %x %x %x %x %x\r\n", buf[0], buf[1], buf[2], buf[3], buf[4], buf[5], buf[6], buf[7], buf[8], buf[9],
																																			buf[10], buf[11], buf[12], buf[13], buf[14]);

		if(buf[0] == 0xaa) {
			break;
		}
		//printf("%x | ", buf[0]);
		memset(buf, 0, sizeof(buf));
		sleep(1);
	}
	printf("uart end\n");
//	close(fd);

   //pthread_exit(NULL);
}

void uart_thread_init()
{
	pthread_t threads;

	int rc, result;

	printf("creating thread \r\n");
	rc = pthread_create(&threads, NULL, PrintHello, NULL);

	  if (rc) {
		 printf("Error:unable to create thread, %d\n", rc);
		 exit(-1);
	  }

	pthread_join(threads, (void *)&result);
	printf("thread join : %d", result);



	return;
}










