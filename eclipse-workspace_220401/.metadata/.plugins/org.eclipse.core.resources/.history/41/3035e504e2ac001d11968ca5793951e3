/*
 * Vector_SocketQueue.h
 *
 *  Created on: 2021. 12. 15.
 *      Author: hong
 */

#ifndef VECTOR_SOCKETQUEUE_H_
#define VECTOR_SOCKETQUEUE_H_

#include "pch.h"
#include <vector>
#if 0
template <typename T>

class VectorSocket {
	T* data;
	int capacity;
	int length;

public:
	VectorSocket(int n =1) : data(new T[n]), capacity(n), length(0){}

	void push_back(T s) {
		if(capacity <= length) {
			T* temp = new T[capacity *2 ];
			for(int i=0; i< length; i++) {
				temp[i] = data[i];
			}
			delete[] data;
			data = temp;
			capacity *= 2;
		}

		data[length] = s;
		length++;
	}

	T operator[] (int i) {return data[i];}

	void remove(int x) {
		for(int i=x+1; i< length; i++) {
			data[i-1] = data[i];
		}
		length--;
	}

	int size() { return length;}

	~VectorSocket() {
		if(data ) {
			delete[] data;
		}
	}

};
#else

typedef struct _sig_ucontext {
  unsigned long uc_flags;
  struct ucontext *uc_link;
  stack_t uc_stack;
  struct sigcontext uc_mcontext;
  sigset_t uc_sigmask;
} sig_ucontext_t;


void crit_err_hdlr(int sig_num, siginfo_t * info, void * ucontext)
{
  void * array[50];
  void * caller_address;
  char ** messages;
  int size, i;
  sig_ucontext_t *uc;

  uc = (sig_ucontext_t *) ucontext;

  /* Get the address at the time the signal was raised */
  caller_address = (void *) uc->uc_mcontext.arm_pc;  // RIP: x86_64 specific     arm_pc: ARM

  fprintf(stderr, "\n");

  if (sig_num == SIGSEGV)
    printf("signal %d (%s), address is %p from %p\n", sig_num, strsignal(sig_num), info->si_addr,
           (void *) caller_address);
  else
    printf("signal %d (%s)\n", sig_num, strsignal(sig_num));

  size = backtrace(array, 50);
  /* overwrite sigaction with caller's address */
  array[1] = caller_address;
  messages = backtrace_symbols(array, size);

  /* skip first stack frame (points here) */
  for (i = 1; i < size && messages != NULL; ++i) {
    printf("[bt]: (%d) %s\n", i, messages[i]);
  }
  free(messages);

  exit(EXIT_FAILURE);
}

void installSignal(int __sig)
{
  struct sigaction sigact;
  sigact.sa_sigaction = crit_err_hdlr;
  sigact.sa_flags = SA_RESTART | SA_SIGINFO;
  if (sigaction(__sig, &sigact, (struct sigaction *) NULL) != 0) {
    fprintf(stderr, "error setting signal handler for %d (%s)\n", __sig, strsignal(__sig));
    exit(EXIT_FAILURE);
  }
}

#endif

#endif /* VECTOR_SOCKETQUEUE_H_ */
